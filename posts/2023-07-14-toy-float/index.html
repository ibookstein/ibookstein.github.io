<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
        }
    </style>

    
    
    
    
    
    

    
    <title>Toy Arbitrary-Precision Float in Rust</title>
    <meta name="description" content="Itay&#39;s blog">
    <meta name="keywords" content='blog, tech, rust, ieee754'>

    <meta property="og:url" content="https://ibookstein.github.io/posts/2023-07-14-toy-float/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Toy Arbitrary-Precision Float in Rust">
    <meta property="og:description" content="Itay&#39;s blog">
    <meta property="og:image" content="https://ibookstein.github.io/">
    <meta property="og:image:secure_url" content="https://ibookstein.github.io/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Toy Arbitrary-Precision Float in Rust">
    <meta name="twitter:description" content="Itay&#39;s blog">
    <meta property="twitter:domain" content="https://ibookstein.github.io/posts/2023-07-14-toy-float/">
    <meta property="twitter:url" content="https://ibookstein.github.io/posts/2023-07-14-toy-float/">
    <meta name="twitter:image" content="https://ibookstein.github.io/">

    
    <link rel="canonical" href="https://ibookstein.github.io/posts/2023-07-14-toy-float/">

    
    <link rel="stylesheet" type="text/css" href="/css/normalize.min.css" media="print">

    
    <link rel="stylesheet" type="text/css" href="/css/main.min.css">

    
    <link id="dark-theme" rel="stylesheet" href="/css/dark.min.css">

    
    <script src="/js/bundle.min.676096fc3ebd5fc54d9f5116926446daff1ba3fec34dc5f56eaa5a9ef988b621.js" integrity="sha256-Z2CW/D69X8VNn1EWkmRG2v8bo/7DTcX1bqpanvmItiE="></script>

    
    
        <style>
    /* Disable floating header. */

    #content {
        margin-top: 0 !important;
    }

    .header {
        position: relative !important;
    }

    .header-shadow {
        box-shadow: none !important;
    }
    </style>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css"
    integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"
        integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx"
        crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"
        integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false }
                ]
            });
        });
    </script>
  
    
</head>
<body>
        <script>
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        

        <div class="nav-title">
            <a class="nav-brand" href="https://ibookstein.github.io/">Layer of Indirection</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://ibookstein.github.io/"><span data-feather='home'></span> Home </a>
            </div>
            
            <div class="nav-link">
                <a href="https://ibookstein.github.io/posts/"><span data-feather='book'></span> Posts </a>
            </div>
            
            <div class="nav-link">
                <a href="https://ibookstein.github.io/projects/"><span data-feather='code'></span> Projects </a>
            </div>
            
            <div class="nav-link">
                <a href="https://ibookstein.github.io/tags/"><span data-feather='tag'></span> Tags </a>
            </div>
            
            <div class="nav-link">
                <a href="https://github.com/ibookstein"><span data-feather='github'></span>  </a>
            </div>
            
            <div class="nav-link">
                <a href="https://ibookstein.github.io/index.xml"><span data-feather='rss'></span>  </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span class="sr-only dark-theme-toggle-screen-reader-target"></span>
                <a>
                    <span class="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
                <a>
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://ibookstein.github.io/"><span data-feather='home'></span> Home </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://ibookstein.github.io/posts/"><span data-feather='book'></span> Posts </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://ibookstein.github.io/projects/"><span data-feather='code'></span> Projects </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://ibookstein.github.io/tags/"><span data-feather='tag'></span> Tags </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://github.com/ibookstein"><span data-feather='github'></span>  </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://ibookstein.github.io/index.xml"><span data-feather='rss'></span>  </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                    <a>
                        <span class="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>Toy Arbitrary-Precision Float in Rust</h1>
        <small role="doc-subtitle"></small>
        <p class="post-date">July 14, 2023
        
        </p>

        <ul class="post-tags">
        
            <li class="post-tag"><a href="https://ibookstein.github.io/tags/rust">rust</a></li>
        
            <li class="post-tag"><a href="https://ibookstein.github.io/tags/ieee754">ieee754</a></li>
        
        </ul>
    </div>

    <div class="post-content">
        <p>In this post, we&rsquo;re going to get our hands dirty writing a toy arbitrary-precision
floating point implementation in Rust. I&rsquo;m therefore going to assume basic
knowledge of IEEE754 (binary) floating point numbers. If you feel unprepared,
I can recommend the following articles, which contain excellent visualizations:</p>
<ul>
<li>Bartosz Ciechanowski&rsquo;s <a href="https://ciechanow.ski/exposing-floating-point/">Exposing Floating Point</a>.</li>
<li>Michael Matloka&rsquo;s <a href="https://matloka.com/blog/floating-point-101">Floating-point arithmetic â€“ all you need to know, explained interactively</a>.</li>
</ul>
<p>Having an arbitrary-precision implementation is useful for pedagogical purposes,
because a good mental model for IEEE754 floating point computations is to pretend
that each computation happens in ideal math land, and is then brought back down
to finite precision land as a separate post-processing step. Everything beyond
that is &ldquo;just&rdquo; optimizations.</p>
<p>Let&rsquo;s ignore the special values for now, and focus on the values everyone
imagines when they think about floating-point values. Well, we basically just
want a mantissa, an exponent, and a sign, right?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    sign: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    exponent: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>    mantissa: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Is this it? Well, we have 32 bits of precision here, the number of bits we
granted the <code>mantissa</code> field. A bit of a far cry from arbitrary-precision,
if you ask me. It&rsquo;s sufficient to hold single-precision values, which require
24 bits of precision. But it will struggle to hold double-precision values,
which require 53 bits of precision. And it will definitely struggle to hold
the results of arithmetic between two such floats.</p>
<p>Introducing <a href="https://docs.rs/num-bigint/latest/num_bigint/"><code>num-bigint</code></a>.
This crate has types for arbitrary-precision integers, so we can use them
to hold our mantissa:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    sign: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    exponent: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>    mantissa: <span style="color:#a6e22e">BigUint</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But wait, shouldn&rsquo;t we also make the <code>exponent</code> field a <code>BigUint</code>? The exponent
field describes, well, exponential growth of our floating-point number. A value
of 10000 in the exponent field means that the number has the value
$\mathrm{mantissa} \cdot 2^{10000}$. That&rsquo;s plenty, so <code>i32</code> will suffice.</p>
<p>Also, rather than having separate <code>sign</code> and <code>BigUint</code> fields, we can use
the <code>BigInt</code> type, which already has a sign. This will let us avoid dealing
with sign management code, and we won&rsquo;t need to carefully avoid underflows
when subtracting <code>BigUint</code>-s:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    exponent: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>    number: <span style="color:#a6e22e">BigInt</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, let&rsquo;s handle the three special value categories we neglected earlier: zeros,
infinities, and NaNs. The former two have a meaningful sign, but no behavior is
ascribed to the sign bit of NaNs. Signed zeros, and the sign has meaningful
behavior, wild!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    Regular { exponent: <span style="color:#66d9ef">i32</span>, number: <span style="color:#a6e22e">BigInt</span> },
</span></span><span style="display:flex;"><span>    Zero { sign: <span style="color:#66d9ef">bool</span> },
</span></span><span style="display:flex;"><span>    Infinity { sign: <span style="color:#66d9ef">bool</span> },
</span></span><span style="display:flex;"><span>    NaN,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s kind of annoying that we&rsquo;ll have to handle the sign&rsquo;s behavior
non-uniformly across these variants. We can instead hoist the <code>number</code> field
out of <code>Regular</code>, and make the sign state of the other variants ride on it.
We&rsquo;ll also be giving NaNs a sign, but it doesn&rsquo;t matter. We&rsquo;ll also use this
opportunity to slightly shorten the names of the fields.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">FloatKind</span> {
</span></span><span style="display:flex;"><span>    Regular { exp: <span style="color:#66d9ef">i32</span> },
</span></span><span style="display:flex;"><span>    Zero,
</span></span><span style="display:flex;"><span>    Infinity,
</span></span><span style="display:flex;"><span>    NaN,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    kind: <span style="color:#a6e22e">FloatKind</span>,
</span></span><span style="display:flex;"><span>    num: <span style="color:#a6e22e">BigInt</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> ArbFloat {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(kind: <span style="color:#a6e22e">FloatKind</span>, num: <span style="color:#a6e22e">BigInt</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self { kind, num }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There&rsquo;s a hidden invariant here we haven&rsquo;t mentioned yet, which must be
maintained for this data structure. The sign maintained by the <code>BigInt</code> type
is of the following type: <code>pub enum Sign { Minus, NoSign, Plus }</code>. But we
already have a <code>Zero</code> variant, and we need to maintain a sign state for it.
So basically <code>num</code> should always be nonzero. For <code>Zero</code>, <code>Infinity</code>, and <code>NaN</code>,
we&rsquo;ll restrict ourselves even further and say that it should always be equal
to $\pm 1$.</p>
<p>Alright, say we have a floating point value in one of the many IEEE754 or
IEEE754-like binary interchange formats. How do we ingest such a value into
our data structure?</p>
<p>We don&rsquo;t want to write a separate parsing routine for each such format, that
would be quite duplicative and bug-prone. So we want a parametric description
of an IEEE754-like format. Basically, all we need to know is how many bits
are in the mantissa field, and how many bits are in the exponent field (the
sign field always has one bit).</p>
<p>For simplicity&rsquo;s sake, we&rsquo;ll only support interchange formats up to 64 bits in
size. This fits formats like <code>binary16</code> (half-precision),
<code>bfloat16</code> (&ldquo;brain floating point&rdquo;), <code>binary32</code> (single-precision), and
<code>binary64</code> (double-precision).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IntStorage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">u64</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FormatDesc</span> {
</span></span><span style="display:flex;"><span>    frac_bits: <span style="color:#66d9ef">u8</span>,
</span></span><span style="display:flex;"><span>    exp_bits: <span style="color:#66d9ef">u8</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> FormatDesc {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">BINARY32</span>: <span style="color:#a6e22e">Self</span> <span style="color:#f92672">=</span> Self {
</span></span><span style="display:flex;"><span>        frac_bits: <span style="color:#ae81ff">23</span>,
</span></span><span style="display:flex;"><span>        exp_bits: <span style="color:#ae81ff">8</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">BINARY64</span>: <span style="color:#a6e22e">Self</span> <span style="color:#f92672">=</span> Self {
</span></span><span style="display:flex;"><span>        frac_bits: <span style="color:#ae81ff">52</span>,
</span></span><span style="display:flex;"><span>        exp_bits: <span style="color:#ae81ff">11</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse</span>(desc: <span style="color:#a6e22e">FormatDesc</span>, storage: <span style="color:#a6e22e">IntStorage</span>) -&gt; <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    todo!()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s add some convenience methods on <code>FormatDesc</code> so that we&rsquo;ll be able
to extract the three different fields of the storage format.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> FormatDesc {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mask</span>(bits: <span style="color:#66d9ef">u32</span>) -&gt; <span style="color:#a6e22e">IntStorage</span> {
</span></span><span style="display:flex;"><span>        IntStorage::<span style="color:#66d9ef">MAX</span> <span style="color:#f92672">&gt;&gt;</span> (IntStorage::<span style="color:#66d9ef">BITS</span> <span style="color:#f92672">-</span> bits)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">frac_mask</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">IntStorage</span> {
</span></span><span style="display:flex;"><span>        Self::mask(self.frac_bits <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">frac_shift</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">IntStorage</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">biased_exp_mask</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">IntStorage</span> {
</span></span><span style="display:flex;"><span>        Self::mask(self.exp_bits <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">biased_exp_shift</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">IntStorage</span> {
</span></span><span style="display:flex;"><span>        self.frac_shift() <span style="color:#f92672">+</span> self.frac_bits <span style="color:#66d9ef">as</span> IntStorage
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sign_mask</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">IntStorage</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sign_shift</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">IntStorage</span> {
</span></span><span style="display:flex;"><span>        self.biased_exp_shift() <span style="color:#f92672">+</span> self.exp_bits <span style="color:#66d9ef">as</span> IntStorage
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Great. Now let&rsquo;s start parsing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse</span>(desc: <span style="color:#a6e22e">FormatDesc</span>, storage: <span style="color:#a6e22e">IntStorage</span>) -&gt; <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> frac <span style="color:#f92672">=</span> (storage <span style="color:#f92672">&gt;&gt;</span> desc.frac_shift()) <span style="color:#f92672">&amp;</span> desc.frac_mask();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> biased_exp <span style="color:#f92672">=</span> (storage <span style="color:#f92672">&gt;&gt;</span> desc.biased_exp_shift()) <span style="color:#f92672">&amp;</span> desc.biased_exp_mask();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> sign <span style="color:#f92672">=</span> ((storage <span style="color:#f92672">&gt;&gt;</span> desc.sign_shift()) <span style="color:#f92672">&amp;</span> desc.sign_mask()) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ArbFloat::new(todo!(), todo!())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we have the raw fields, how do we reason about them to create an <code>ArbFloat</code>?
Let&rsquo;s start with computing the <code>FloatKind</code>. We know that when the <code>biased_exp</code>
field is all-ones, then we&rsquo;re dealing either with a <code>NaN</code> (when <code>frac != 0</code>)
or with an <code>Infinity</code> (when <code>frac == 0</code>). We also know that when the <code>biased_exp</code>
field is all-zeros, then we&rsquo;re dealing either with a subnormal number (when <code>frac != 0</code>)
or with a zero (when <code>frac == 0</code>). Let&rsquo;s sketch that out:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse</span>(desc: <span style="color:#a6e22e">FormatDesc</span>, storage: <span style="color:#a6e22e">IntStorage</span>) -&gt; <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> frac <span style="color:#f92672">=</span> (storage <span style="color:#f92672">&gt;&gt;</span> desc.frac_shift()) <span style="color:#f92672">&amp;</span> desc.frac_mask();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> biased_exp <span style="color:#f92672">=</span> (storage <span style="color:#f92672">&gt;&gt;</span> desc.biased_exp_shift()) <span style="color:#f92672">&amp;</span> desc.biased_exp_mask();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> sign <span style="color:#f92672">=</span> ((storage <span style="color:#f92672">&gt;&gt;</span> desc.sign_shift()) <span style="color:#f92672">&amp;</span> desc.sign_mask()) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> kind <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> biased_exp <span style="color:#f92672">==</span> desc.biased_exp_mask() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> frac <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            FloatKind::Infinity
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            FloatKind::NaN
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> biased_exp <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> frac <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            FloatKind::Zero
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Subnormals.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            FloatKind::Regular { exp: <span style="color:#a6e22e">todo</span><span style="color:#f92672">!</span>() }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        FloatKind::Regular { exp: <span style="color:#a6e22e">todo</span><span style="color:#f92672">!</span>() }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    ArbFloat::new(kind, todo!())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Almost there. We&rsquo;re only missing an assignment for <code>exp</code> and <code>num</code>. We&rsquo;ll need
to introduce a couple of helper methods on the <code>FormatDesc</code> structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> FormatDesc {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">precision</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>        self.frac_bits <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Move the unsigned (biased) exponent in the [1, 2^bits - 2] range to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// the signed [-2^{bits - 1} + 2, 2^{bits - 1} - 1] range.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">exp_bias</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>        (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (self.exp_bits <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The hidden bit -- the implicit bit to the left of the radix point.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">integer_bit</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">IntStorage</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> self.frac_bits
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And now we can put everything together:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse</span>(desc: <span style="color:#a6e22e">FormatDesc</span>, storage: <span style="color:#a6e22e">IntStorage</span>) -&gt; <span style="color:#a6e22e">ArbFloat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> frac <span style="color:#f92672">=</span> (storage <span style="color:#f92672">&gt;&gt;</span> desc.frac_shift()) <span style="color:#f92672">&amp;</span> desc.frac_mask();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> biased_exp <span style="color:#f92672">=</span> (storage <span style="color:#f92672">&gt;&gt;</span> desc.biased_exp_shift()) <span style="color:#f92672">&amp;</span> desc.biased_exp_mask();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> sign <span style="color:#f92672">=</span> ((storage <span style="color:#f92672">&gt;&gt;</span> desc.sign_shift()) <span style="color:#f92672">&amp;</span> desc.sign_mask()) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// We add the precision to the bias to be able to interpret the fraction
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// field as an integer rather than as a fixed-point number in [1, 2).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// We&#39;ve essentially moved the radix point to the right by multiplying
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// the fraction by `2^(precision - 1)`, so we compensate by subtracting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// `precision - 1` from the exponent.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> exp <span style="color:#f92672">=</span> biased_exp <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span> <span style="color:#f92672">-</span> (desc.exp_bias() <span style="color:#f92672">+</span> desc.precision() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num <span style="color:#f92672">=</span> BigInt::from(<span style="color:#66d9ef">if</span> sign { <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> } <span style="color:#66d9ef">else</span> { <span style="color:#ae81ff">1</span> });
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> kind <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> biased_exp <span style="color:#f92672">==</span> desc.biased_exp_mask() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> frac <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            FloatKind::Infinity
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            FloatKind::NaN
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> biased_exp <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> frac <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            FloatKind::Zero
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Subnormals.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            num <span style="color:#f92672">*=</span> frac;
</span></span><span style="display:flex;"><span>            FloatKind::Regular { exp: <span style="color:#a6e22e">exp</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        num <span style="color:#f92672">*=</span> frac <span style="color:#f92672">|</span> desc.integer_bit();
</span></span><span style="display:flex;"><span>        FloatKind::Regular { exp }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    ArbFloat::new(kind, num)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a bit gnarly, but then so is IEEE754. ðŸ˜‰
Let&rsquo;s see what this prints out for a couple of examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_examples</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, parse(FormatDesc::<span style="color:#66d9ef">BINARY32</span>, <span style="color:#ae81ff">0x8000_0000</span>)); <span style="color:#75715e">// -0f32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, parse(FormatDesc::<span style="color:#66d9ef">BINARY32</span>, <span style="color:#ae81ff">0x7F80_0000</span>)); <span style="color:#75715e">// f32::INFINITY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, parse(FormatDesc::<span style="color:#66d9ef">BINARY32</span>, <span style="color:#ae81ff">0x7FC0_0000</span>)); <span style="color:#75715e">// f32::NAN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, parse(FormatDesc::<span style="color:#66d9ef">BINARY32</span>, <span style="color:#ae81ff">0x3F80_0000</span>)); <span style="color:#75715e">// 1f32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, parse(FormatDesc::<span style="color:#66d9ef">BINARY64</span>, <span style="color:#ae81ff">0x3FF0_0000_0000_0000</span>)); <span style="color:#75715e">// 1f64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>This prints out:</p>
<pre tabindex="0"><code>ArbFloat { kind: Zero, num: -1 }
ArbFloat { kind: Infinity, num: 1 }
ArbFloat { kind: NaN, num: -1 }
ArbFloat { kind: Regular { exp: -23 }, num: 8388608 }
ArbFloat { kind: Regular { exp: -52 }, num: 4503599627370496 }
</code></pre><p>This is almost right, but we&rsquo;re now faced with an inconvenient reality of
floating-point numbers: uniqueness of representation is not a given, it must be
earned! In particular, we see here two different representations for the number 1.</p>
<p>This stems from the fact that we can &ldquo;trade&rdquo; between the mantissa and the
exponent by multiplying the mantissa by 2 and then subtracting 1 from the
exponent to compensate, and vice versa. Therefore, every number $m \cdot 2^{e}$
has a many different &ldquo;aliases&rdquo;, of the form $(m \cdot 2^{d}) \cdot 2^{e - d}$.</p>
<p>In the IEEE754 binary interchange formats, this problem is neatly defined out
of existence by saying that the mantissa always represents a fraction in the
interval $[1, 2)$. And throw away the top bit, since it&rsquo;s always 1, while you&rsquo;re
at it. In other words, the single alias with $1 \le m &lt; 2$ is the only one that
can be encoded. Other aliases would need to either set bits above the implicit
bit or unset the implicit bit itself.</p>
<p>I did lie in the previous paragraph. Just a bit. The mantissa doesn&rsquo;t always
represent a fraction in the interval $[1, 2)$, due to the existence of subnormals.
But they&rsquo;re defined in a way that does not break uniqueness of representation,
and meshes well with gradual underflow towards zero.</p>
<p>For subnormal numbers (<code>biased_exp == 0, mantissa != 0</code>), IEEE754 essentially
degrades into a fixed-point representation. The meaning of the number is
$0.\mathrm{mantissa} \cdot 2^{E_\mathrm{min}}$. The drop from <code>biased_exp == 1</code>
to <code>biased_exp == 0</code> does not represent a drop in the numeric value of the
exponent in the regular way, but rather, we start digging into the mantissa
and losing precision gradually. Dividing a number with <code>biased_exp == 2</code> by 2
would leave us with <code>biased_exp == 1</code> and the same mantissa. Dividing a
number with <code>biased_exp == 1</code> by 2 would leave us with <code>biased_exp == 0</code>, but
also shift the mantissa right one bit position, essentially shifting the hidden
bit into the mantissa itself (which means that the hidden bit becomes zero; we
stole it into the mantissa!).</p>
<p>So, how does all this apply to us? What do we do to always have a single
representation for every number? Well, we could just &ldquo;right-justify&rdquo; the <code>BigInt</code>
to the best degree we can. We divide the mantissa by the largest power of two
that divides it, and donate it to the exponent. This does depart from the IEEE754
perspective of putting the normalization anchor &ldquo;to the left&rdquo; of the number,
in the radix point. We&rsquo;re putting our normalization anchor &ldquo;to the right&rdquo;, by
saying that we only ever deal with integers in our analogue for the mantissa
(and only odd integers, at that).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> ArbFloat {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(<span style="color:#66d9ef">mut</span> kind: <span style="color:#a6e22e">FloatKind</span>, <span style="color:#66d9ef">mut</span> num: <span style="color:#a6e22e">BigInt</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> FloatKind::Regular { exp } <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> kind {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> adjustment <span style="color:#f92672">=</span> num.trailing_zeros().unwrap() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>exp <span style="color:#f92672">+=</span> adjustment;
</span></span><span style="display:flex;"><span>            num <span style="color:#f92672">&gt;&gt;=</span> adjustment;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Self { kind, num }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Re-running, we now get the following output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>ArbFloat { kind: <span style="color:#a6e22e">Zero</span>, num: <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> }
</span></span><span style="display:flex;"><span>ArbFloat { kind: <span style="color:#a6e22e">Infinity</span>, num: <span style="color:#ae81ff">1</span> }
</span></span><span style="display:flex;"><span>ArbFloat { kind: <span style="color:#a6e22e">NaN</span>, num: <span style="color:#ae81ff">1</span> }
</span></span><span style="display:flex;"><span>ArbFloat { kind: <span style="color:#a6e22e">Regular</span> { exp: <span style="color:#ae81ff">0</span> }, num: <span style="color:#ae81ff">1</span> }
</span></span><span style="display:flex;"><span>ArbFloat { kind: <span style="color:#a6e22e">Regular</span> { exp: <span style="color:#ae81ff">0</span> }, num: <span style="color:#ae81ff">1</span> }
</span></span></code></pre></div><p>We can even parse the <a href="http://tom7.org/nand/">fabled/cursed binary3 format</a>!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_binary3</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">BINARY3</span>: <span style="color:#a6e22e">FormatDesc</span> <span style="color:#f92672">=</span> FormatDesc {
</span></span><span style="display:flex;"><span>        frac_bits: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        exp_bits: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">8</span> {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, parse(<span style="color:#66d9ef">BINARY3</span>, x));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>ArbFloat { kind: Zero, num: 1 }
ArbFloat { kind: Regular { exp: 0 }, num: 1 }
ArbFloat { kind: Infinity, num: 1 }
ArbFloat { kind: NaN, num: 1 }
ArbFloat { kind: Zero, num: -1 }
ArbFloat { kind: Regular { exp: 0 }, num: -1 }
ArbFloat { kind: Infinity, num: -1 }
ArbFloat { kind: NaN, num: -1 }
</code></pre><p>Next time, we&rsquo;ll take a shot at implementing multiplication and rounding.</p>

        
    </div>

    <div class="prev-next">
        
    </div>

    
    
    
</div>

<aside class="post-toc">
    <nav id="toc">
        <nav id="TableOfContents"></nav>
    </nav>
</aside>



    

        </main><footer class="footer">
    <span>&copy; 2024 </span>
    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/526avijitgupta/gokarna">Gokarna</a>
    </span>
</footer></body>
</html>
